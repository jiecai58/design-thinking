# design-thinking 

## 总纲

### 单一职责原则

应该有且仅有一个原因引起类的变更. 
最佳实践: 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

### 里氏替换原则

标准定义

1. 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
2. 所有引用基类的地方必须能透明地使用其子类的对象。

4条含义
1. 子类必须完全实现父类的方法
2. 子类可以有自己的个性, 但尽量要控制
3. 覆盖或实现父类的方法时输入参数可以被放大
4. 覆写或实现父类的方法时输出结果可以被缩小

### 依赖倒置原则
在真实的自然界中我们都是直接依赖各种真实的实现的. 而在程序世界. 我们要依赖接口或者抽象类. 从实现到抽象或者接口的转变叫依赖倒置

* 高层模块不依赖底层模块. 两者都应该依赖其抽象.
* 抽象不应该依赖细节
* 细节应该依赖其抽象.

依赖倒置原则. 翻译成java语言版本:

* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
* 接口或抽象类不依赖于实现类；
* 实现类依赖接口或抽象类。

依赖的三种写法: 只要用到抽象依赖. 即使是多层的传递依赖也无所谓
1. 构造函数依赖
2. set方法依赖
3. 接口声明的时候产生依赖

最佳实践:
1. 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
2. 变量的表面类型尽量是接口或者是抽象类
3. 任何类都不应该从具体类派生
4. 尽量不要覆写基类的方法 如果基类是抽象类, 尽量不要去重写基类已经实现的方法, 抽象方法是可以的.
5. 结合里氏替换原则使用

### 接口隔离原则

1. Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）
2. The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）

这里的接口即指类. 也指接口

通俗点说的意思就是 接口要功能要细化. 客户端在用接口的时候, 只提供它需要的接口即可.

单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。
例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，
按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。
专门的接口指什么？就是指提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问

保持接口的纯净性:
1. 接口要尽量的小, 但是小也是有限度的, 不能违反接口单一原则.
2. 接口要高内聚
什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。 接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。
3. 定制服务
一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务，什么是定制服务？定制服务就是单独为一个个体提供优良的服务。
4. 接口设计是有限度的
这个度需要权衡

最佳实践:
* 一个接口只服务于一个子模块或业务逻辑；

* 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；

* 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；

* 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！

### 迪米特法则
迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）
也叫最少知识原则. 即虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

### 开闭原则(总纲中的总纲)
Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）

软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。那什么又是软件实体呢？软件实体包括以下几个部分：

* 项目或软件产品中按照一定的逻辑规则划分的模块。
* 抽象和类。
* 方法。




